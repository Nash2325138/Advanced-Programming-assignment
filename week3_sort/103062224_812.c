#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

/*#define VERSION_ONE_FAILED__SO_SAD__QQ*/
#define VERSION_TWO
/* Originally I think version one is better... sign...... */

#ifdef VERSION_TWO
int yards;
int length[60];
int profit[60][30];

int sameProfit[60][30];
int spSize[60];

int counting_sort[1100];
/* sorting range: 0 ~ 50*20  */

int calMaxProfit(void)
{
	/* calculate maximum profit and log all possible choices of the same pile which can reach max profit */
	int total_max = 0;
	int i;
	for(i=0 ; i<yards ; i++)
	{
		int max = 0 ,  sum = 0;
		int j;

		/* initially, we can choose nothing (0 box), at this time profit==0 */
		sameProfit[i][0] = 0;
		spSize[i] = 1;

		for(j=0 ; j<length[i] ; j++)
		{
			sum += profit[i][j];
			if (sum > max){
				max = sum;
				sameProfit[i][0] = j+1;
				spSize[i] = 1;
			} else if (sum==max){
				sameProfit[i][spSize[i]] = j+1;
				spSize[i]++;
			}
		}
		/* it's likely that max will be 0 */
		total_max += max;
	}
	return total_max;
}

void dfsSearch(int yard_id, int boxes_accumulated )
{
	if( yard_id >= yards ){
		counting_sort[boxes_accumulated] = 1;
		return;
	}

	int i;
	for(i=0 ; i<spSize[yard_id] ; i++){
		dfsSearch( yard_id+1 , boxes_accumulated + sameProfit[yard_id][i] );
	}
}

int main()
{
	scanf("%d", &yards);
	int gg=0;
	while(yards>0)
	{
		gg++;

		int i;
		for(i=0 ; i<yards ; i++)
		{
			scanf("%d", &length[i]);
			int j;
			for(j=0 ; j<length[i] ; j++)
			{
				int temp;
				scanf("%d", &temp);
				profit[i][j] = 10-temp;
			}
		}
		int maxProfit = calMaxProfit();

		printf("Workyards %d\n", gg);
		printf("Maximum profit is %d.\n", maxProfit);

		/*int ti, tj;
		for(ti=0 ; ti<yards ; ti++){
			for(tj=0 ; tj<spSize[ti] ; tj++){
				printf("%d ", sameProfit[ti][tj]);
			}
			printf("\n");
		}*/
		int j;
		for(j=0 ; j<1100; j++) counting_sort[j] = 0;

		dfsSearch(0, 0);
		printf("Number of pruls to buy:");
		int count = 0;
		for(j=0 ; j<1100; j++){
			if(counting_sort[j]==1){
				printf(" %d", j);
				count++;
			}
			if(count >= 10) break;
		}
		if(count==0) printf(" 0");
		printf("\n");

		scanf("%d", &yards);
		if(yards!=0) printf("\n");
	}
	return 0;
}
#endif



#ifdef VERSION_ONE_FAILED__SO_SAD__QQ

typedef struct candidate{
	int now;
	int base[60];
}candidate;
candidate candidates[600000];
int cddSize;

int yards;
int length[60];
int profit[60][30];

int sameProfit[60][30];
int spSize[60];

/*  return value is a historical mistake XDD, which turns out to be useless */

int generate_and_put_candidate(candidate *last)
{
	/* NULL means it's the first one created and put*/
	/* in theory, every candidate (except for the first one) will be generated by another candidate */
	/* a last candidate can at most generate #{yards} other candidates*/
	int i;
	if( last==NULL ){
		candidates[0].now = 0;
		for(i=0 ; i<yards ; i++){
			candidates[0].now += sameProfit[i][0];		/* it might += 0 */
			candidates[0].base[i] = 0;
		}
		cddSize = 1;
		return 1;
	}

	int flag=0;
	for(i=0 ; i<yards ; i++)
	{
		/*printf(" , base[%d]==%d  ", i, last->base[i]);*/
		if( last->base[i]+1 >= spSize[i] ) continue;

		candidates[cddSize].now = last->now - sameProfit[i][last->base[i]] + sameProfit[i][last->base[i]+1];
		int j;
		for(j=0 ; j<yards ; j++) candidates[cddSize].base[j] = last->base[j];
		candidates[cddSize].base[i]++;
		cddSize++;
		flag=1;
	}
	return flag;
	/* return whether this function has generated any new candidate */
}

int calMaxProfit(void)
{
	/* calculate maximum profit and log all possible choices of the same pile which can reach max profit */
	int total_max = 0;
	int i;
	for(i=0 ; i<yards ; i++)
	{
		int max = 0 ,  sum = 0;
		int j;

		sameProfit[i][0] = 0;
		spSize[i] = 1;

		for(j=0 ; j<length[i] ; j++)
		{
			sum += profit[i][j];
			if (sum > max){
				max = sum;
				sameProfit[i][0] = j+1;
				spSize[i] = 1;
			} else if (sum==max){
				sameProfit[i][spSize[i]] = j+1;
				spSize[i]++;
			}
		}
		total_max += max;
	}
	return total_max;
}


int main()
{
	scanf("%d", &yards);
	int gg=0;
	while(yards>0)
	{
		gg++;

		int i;
		for(i=0 ; i<yards ; i++)
		{
			scanf("%d", &length[i]);
			int j;
			for(j=0 ; j<length[i] ; j++)
			{
				int temp;
				scanf("%d", &temp);
				profit[i][j] = 10-temp;
			}
		}
		int maxProfit = calMaxProfit();

		printf("Workyards %d\n", gg);
		printf("Maximum profit is %d.\n", maxProfit);

		/*int ti, tj;
		for(ti=0 ; ti<yards ; ti++){
			for(tj=0 ; tj<spSize[ti] ; tj++){
				printf("%d ", sameProfit[ti][tj]);
			}
			printf("\n");
		}*/

		int ans[11];
		int ansSize = 0;

		generate_and_put_candidate(NULL);
		while(ansSize < 10)
		{
			int k , min=-1, chosen=-1;
			for(k=0 ; k < cddSize ; k++){
				if( candidates[k].now==-1 ) continue;
				if( min==-1 || candidates[k].now<min ){
					min = candidates[k].now;
					chosen = k;
				}
			}

			if(chosen==-1) break;
			/*while(  min<0 || chosen<0  );*/

			/*while(cddSize>590000);*/
			/*printf("chosen min==%d  , cddSize==%d  ", min, cddSize);*/
			if( ansSize==0 )
				ans[ansSize++] = min;
			else if( min!=ans[ansSize-1] )
				ans[ansSize++] = min;

			generate_and_put_candidate(&candidates[chosen]);
			candidates[chosen].now = -1;
			/*printf("cddSize==%d\n", cddSize);*/
		}

		printf("Number of pruls to buy:");
		int j;
		if(ansSize==0)
			printf(" 0");
		else
			for(j=0 ; j<ansSize ; j++) printf(" %d", ans[j]);
		printf("\n");

		scanf("%d", &yards);
		if(yards!=0) printf("\n");
	}
	return 0;
}

#endif
